# Linked List 연결 리스트

---
## LinkedList란?

* 선형의 구조를 띈 동적 자료구조
* 용어:
    * 노드 node: 데이터와 포인터로 구성된 데이터 저장 단위
    * 포인터 pointer: 각 노드 안에서 다음이나 이전의 노드와의 연결정보(저장된 주소값)를 가지고 있는 공간  

<br>

---
## 연결 리스트의 특징

* **특징**:
    * head 포인터: 시작 (head 포인터가 첫번째 노드를 가리킴)
    * tail 포인터: 끝 (마지막 노드는 가리킬 노드가 존재하지 않으므로 가리키는 주소 값은 NULL)

* **장점**:
    * 효율적인 삽입/삭제
        * why? 포인터만 조정하면 되므로 배열과 다르게 기존의 요소들의 이동이 필요치 않다
    * 동적 크기 조정
          * why? 런타임 요소의 갯수를 동적으로 변경 가능하기 때문이다
    * 메모리 낭비 감소
          * why? 각 요소에 대한 다음 요소의 포인터만 저장하기 때문이다

* **단점**:
    * 접근 속도 한계
        * why? 한 요소에 접근하기 위해선 처음부터 순차적으로만 탐색이 가능하기 때문에 배열과 같이 임의의 위치에 직접 접근할 수 없다

* **사용사례**:
    * 삽입/삭제가 빈번한 경우:
        * 큐나 스택과 같은 자료구조를 구현할때 많이 사용된다
    * 메모리 사용 최적화가 필요한 경우

<br>

---
## 시간 복잡도

* O(1): 맨 앞 데이트를 추가/삭제
* O(n): 맨 앞 제외 다른 위치에 데이터를 추가/삭제
    * why? 현재의 위치까지 이동해야 하므로
* O(n): 데이터 접근
    * why? 하나씩 값을 확인해야 하기 때문 

<br>

---
## 연결 리스트의 종류

* **이중 연결 리스트**

    * 앞 노드의 주소값 + 다음 노드의 주소 값 모두 저장
    * 장점: 양방향 탐색이 가능하다
    * 단점: 구현이 어렵고, 주소 값 2개 저장 시 필요한 메모리 양 증가한다

* **원형 연결 리스트**:

    * 마지막 노드가 첫 번째 주소 값을 가리키는 구조
    * 장점:
        * 삽입/삭제 연산 효율성 증가한다
        * 순환 구조로 인해 어떤 노드에서든 다른 노드로 모두 접근이 가능하다

<br>

---
## 구현 코드

```python
class Node:
  def __init__(self, data):
    self.data = data  #data
    self.next = None  #pointer

  def add (self, data):
    # head는 바뀌지 않음 BUT node는 while을 돌면서 계속 바뀜
    node = head  # 첫 노드
    while node.next: # node가 가르키는 node.next에 자료가 있으면; True로 보고 있음 (0,'', False, None 제외 모두 True)
      node = node.next # 이 노드는 가르키는 포인터의 노드로 바뀜
    node.next = Node(data) # 입력된 data로 새로운 노드 객체 생성 b/c 대문자"N"ode이니까 객체 생성 > 그리고 마지막 node.next (pointer)에는 (현재는 None인) 새로운 생성된 노드 객체 (주소)가 들어감; Node(data)를 가르키는    
```

<br>

---

## 예상 질문

연결 리스트란 무엇이며, 어떻게 구성되어 있는지 설명해보시오.
> 연결 리스트는 데이터의 요소들을 순서대로 저장하는 선형의 동적 자료구조에 해당합니다. 각 요소는 노드라고 불리며, 데이터와 다음 요소를 가르키는 포인터로 구성되어 있습니다. 첫 번째 노드를 가리키는 Head가 있고, 마지막 노드의 경우 더 이상 가리킬 노드가 없으므로 NULL을 가리키는 Tail이 있습니다. 이로 인해, 데이터의 삽입/삭제 시 포인터만 수정하면 되기 때문에 배열보다 빠르게 수행할 수 있습니다. 하지만, 특정 요소에 접근을 원할 경우, 순차적으로 탐색을 해야하기 때문에 배열보다 느린 속도를 띕니다. 그러므로, 데이터의 수가 가변적이거나 빈번한 삽입 또는 삭제가 요구되는 데이터에 주로 사용됩니다.

배열과 연결 리스트의 차이점을 설명해보시오.
> 배열과 연결리스트의 가장 큰 차이점은 데이터의 저장 방식입니다. 먼저, 배열은 정적인 선형의 자료구조로써 최대 길이를 미리 설정하여 연속된 메모리 공간에 순차적으로 데이터를 저장합니다. 이로 인해 특정한 요소에 빠른 접근을 원할때 효율적으로 사용된다는 장점이 있습니다. 하지만 삽입 또는 삭제 시 이와 같은 특징 때문에 기존의 요소들을 이동해야 한다는 단점이 있습니다. 그러므로 데이터의 수가 고정적이거나 빈번한 접근이 요구되는 경우 주로 사용됩니다.

> 반면, 연결 리스트의 경우 선형의 동적 자료구조로써 불연속적인 메모리 공간에 데이터를 저장합니다. 각 노드는 데이터와 다음 노드의 주소 값을 저장하고 있습니다. 이로 인해, 데이터의 삽입/삭제 시 포인터만 수정하면 되기 때문에 배열보다 빠르게 수행할 수 있습니다. 하지만, 특정 요소에 접근을 원할 경우, 순차적으로 탐색을 해야하기 때문에 배열보다 느린 속도를 띕니다. 그러므로, 데이터의 수가 가변적이거나 빈번한 삽입 또는 삭제가 요구되는 데이터에 주로 사용됩니다.

단순 연결 리스트를 역순으로 출력하는 방법을 설명해보시오.
> 해당 방법으로는 스택에 연결 리스트의 요소를 순차적으로 넣고 빼는 방법이 있습니다. 이 방법은 스택을 사용하므로 추가 메모리가 요구됩니다. 다른 방법으로는 재귀 함수를 이용하는 것 입니다. 재귀 함수 내에서 현재 노드의 다음 노드를 출력하기 전에 재귀 호출을 통해 다음 노드로 이동합니다. 재귀 호출이 끝나면 현재 노드를 출력합니다.
