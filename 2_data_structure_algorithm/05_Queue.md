# Queue 큐

## Queue 큐란?
    * 줄을 세우는 형식의 FIFO (First In Firso Out) 선입선출 구조이다

![](https://t1.daumcdn.net/cfile/tistory/9929C0495C932BB115)

<br>

---

## 특징

* **특징**:
    * 한 쪽 끝에서 삽입, 다른 한 쪽 끝에서 삭제가 이루어진다
    * 중간 요소에 대한 임의의 접근이나 삽입/삭제는 불가하다
    * 선형의 자료구조로써 순서가 존재한다
    * 단순하고 빠른 성능을 위해 사용하므로 보통 배열로 구현하는 것이 일반적이다

* **장점**:
    * 순차적인 데이터 처리시에 빠르게 수행 가능하다
    * 배열로 구현하기 때문에 간단하다

* **단점**:
    * 큐의 용량은 고정되어 있으므로 동적인 조절이 불가하다
    * 중간의 요소의 접근이 어렵다

* **사용 사례**:
    * 너비우선 탐색 (BFS):
          * 처리해야할 노드의 리스트를 저장하는 용도로 사용한다
          * 노드를 하나 처리할 때마다 해당 노드와 인전한 노드들을 큐에 다시 저장한다
          * 노드를 접근한 순서대로 처리 가능하다
    * 프린터의 출력 처리
    * 콜센터 고객 대기 시간
    * 캐시(Cache) 구현

<br>

---

## 시간 복잡도
* O(1): 삽입/삭제
* O(n): 탐색

<br>

---
## 연산자

* `enqueue()`: 큐에 데이터를 삽입하는 기능
* `dequeue()`: 큐에 데이터를 꺼내는 기능
* `peek or top` - 큐의 맨 앞에 위치한 요소 반환
* `isEmpty` - 스택이 비어있는지 확인
* `isFull` - 스택이 가득 찼는지 확인

<br>

---

## 구현 코드

```python
class Queue():
  def __init__(self, max_size):
    self.max_size = max_size
    self.queue = []

  def enqueue(self, data):
    if len(self.queue) < self.max_size:
      self.queue.append(data)
    else:
      print('Queue is full')

  def dequeue(self):
    if not self.isEmpty():
      return self.queue.pop(0)
    else:
      print('Queue is empty')

  def front(self):
    if not self.isEmpty():
      return self.queue[0]
    else:
      print('Queue is empty')

  def isEmpty(self):
    return len(self.queue) == 0

  def isFull(self):
    return len(self.queue) == self.max_size
```

<br>

---

## 예상 질문
* Stack과 Queue의 차이점에 대해 설명하시오.
> 스택은 쌓아올리는 형식의 후입선출 Last In First Out 구조 입니다. 데이터를 정해진 방향으로 쌓을 수 있으며, 한 방향으로만 접근이 가능하다는 특성이 있습니다. 주로 DFS 나 재귀 알고리즘에 활용됩니다. 이러한 특성으로 웹 브라우저 방문 기록, 뒤로 가기, 실행 취소, 역순 문자열 만들기, 또는 후위 표기법등에 주로 사용됩니다.

> 큐는 줄을 세우는 형식의 선입선출 First In First Out 구조입니다. 큐는 한 쪽 끝에서 삽입을, 다른 한 쪽 끝에서 삭제를 수행합니다. 이러한 특성으로, 주로 데이터가 시간 순서대로 처리되어햐 하는 경우 사용됩니다. 실생활 예시로는 프린터의 출력처리, 콜센터 고객 대기 시간, BFS 구현, 캐시 구현에 사용됩니다.

* Stack과 Queue의 공통점에 대해 설명하시오.
> 공통점으로는 큐와 스택 모두 순차적으로 데이터를 처리한다는 특성이 있씁니다. 이러한 특성으로 일반적으로 배열로 구현이 되기 때문에 중간 요소 임의 삽입/삭제에 어려움이 있습니다. 만약, 두가지 특성을 모두 가지는 자료구조를 원한다면 덱 (Deque: Double-ended Queue)을 사용합니다. 덱은 양쪽 끝에서 데이터 삽입과 삭제가 가능합니다. 따라서, 양 쪽 끝에 연산이 필요한 경우 주로 사용됩니다.

* 스택으로 큐를 구현하는 방법과 큐로 스택을 구현하는 방법에 대해 설명해주세요.
>   1. 스텍으로 큐 구현하기
    스택 2개를 활용해서 구현할 수 있습니다.
    스택 A와 B가 있을 때, 큐에 PUSH연산이 일어나면 스택 A에 PUSH 합니다.
    이후 큐에 POP연산을 한다면 스택A의 모든 데이터를 스택 B로 옮깁니다. 그렇게 되면 스택 A의 역순으로 데이터가 저장될 것이고, 스택 B를 POP하면 큐에 저장된 데이터 순서대로 출력될 것입니다.
    즉, 스택 A는 인큐의 역할, 스택 B는 디큐의 역할을 하게 됩니다.
    PUSH를 하면 스택 A에 가장 늦게 들어온 데이터가 맨 위에 쌓일 것이고, 이를 다시 스택 B로 옮기면 큐의 구조(선입선출)로 저장됩니다.

>   2. 큐로 스택 구현하기
    큐 2개를 활용해서 구현할 수 있습니다.
    큐 A와 B가 있을 때, 스택에 PUSH 연산이 일어나면, 해당 요소를 우선 큐 A에 PUSH 합니다.
    그 다음 마지막 원소(방금 PUSH한 요소)를 제외한 나머지를 큐 B에 옮긴 후, 다시 큐 A에 차례대로 PUSH한다.
    그럼 가장 나중에 들어온 값이 큐의 첫 번째 위치로 이동하게 되고, TOP이나 POP 연산이 일어날 경우 순서에 맞게 데이터를 POP할 수 있다.
